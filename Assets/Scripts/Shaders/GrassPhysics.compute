// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Input and output buffers
float time;
float deltaTime;
float collisionStrength;
float stiffnessCoefficient;
float4x4 objectToWorldMatrix;
RWStructuredBuffer<float> grassLength;
RWStructuredBuffer<float3> grassUp;
RWStructuredBuffer<float4> v1Positions;
RWStructuredBuffer<float4> v2Positions;

float B(float2 v0, float2 v1, float2 v2, float t)
{
    float2 d = 2 * (1 - t) * (v1 - v0) + 2 * t * (v2 - v1);
    return sqrt(d.x * d.x + d.y * d.y);
}

// using legendre-gauss solution: https://pomax.github.io/bezierinfo/#arclength
float BezierCurveArcLength(float2 v0, float2 v1, float2 v2)
{
    float length = 0;
    int n = 3;
    float w[3] = { 0.8888888888888888f, 0.5555555555555556f, 0.5555555555555556f };
    float x[3] = { 0.0f, -0.7745966692414834f, 0.7745966692414834f };
    
    float t;
    for (int i = 0; i < n; i++)
    {
        t = 0.5f * x[i] + 0.5f;
        length += w[i] * B(v0, v1, v2, t);
    }
    return 0.5f * length;
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 up = float3(0, 1, 0);
    float3 vertex0 = float3(0, 0, 0);
    float4 vertex1 = v1Positions[id.x];
    float4 vertex2 = v2Positions[id.x];
    float originalLength = v1Positions[id.x].w;

    // sine v2 movement
    vertex2.x += sin(vertex2.y * 0.001 + time) * 0.0005;

    // calculate v1 position based on v2
    float3 v1_dir = normalize(vertex1.xyz);
    vertex1.xyz = dot(vertex2.xyz, v1_dir) * 0.5f * v1_dir;

    // calculate length
    grassLength[id.x] = BezierCurveArcLength(float2(0, 0), v1Positions[id.x].xy, v2Positions[id.x].xy);
    float lengthDiff = originalLength / grassLength[id.x];

    // correct new length
    float3 v01 = lengthDiff * (vertex1.xyz - vertex0);
    float3 v12 = lengthDiff * (vertex2.xyz - vertex1.xyz);
    vertex1.xyz = v01;
    vertex2.xyz = vertex1.xyz + v12;

    // output
    v1Positions[id.x] = vertex1;
    v2Positions[id.x] = vertex2;
}
