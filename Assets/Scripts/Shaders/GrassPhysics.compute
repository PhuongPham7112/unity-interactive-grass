// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// time updated var
float time;
float deltaTime;
float4x4 objectToWorldMatrix;

// user-provided physical model params
float grassMass;
float collisionStrength;
float stiffnessCoefficient;

// gravity
float gravityParam;
float4 gravityPoint;
float4 gravityDirection;

// buffers
RWStructuredBuffer<float> grassLength;
RWStructuredBuffer<float3> groundPositions;
RWStructuredBuffer<float4> v1Positions;
RWStructuredBuffer<float4> v2Positions;

float B(float2 v0, float2 v1, float2 v2, float t)
{
    float2 d = 2 * (1 - t) * (v1 - v0) + 2 * t * (v2 - v1);
    return sqrt(d.x * d.x + d.y * d.y);
}

// using legendre-gauss solution: https://pomax.github.io/bezierinfo/#arclength
float BezierCurveArcLength(float2 v0, float2 v1, float2 v2)
{
    float length = 0;
    int n = 3;
    // value tables: https://pomax.github.io/bezierinfo/legendre-gauss.html#n3
    float w[3] = { 0.8888888888888888f, 0.5555555555555556f, 0.5555555555555556f };
    float x[3] = { 0.0f, -0.7745966692414834f, 0.7745966692414834f };
    
    float t;
    for (int i = 0; i < n; i++)
    {
        t = 0.5f * x[i] + 0.5f;
        length += w[i] * B(v0, v1, v2, t);
    }
    return 0.5f * length;
}

float3 WindFunction(float3 pos)
{
    // Wind parameters
    float baseFrequency = 0.5;
    float baseAmplitude = 1.0;

    // Wind variation parameters
    float variation1 = sin(time * 0.1) * 0.2 + 0.8; // Slow variation in overall strength
    float variation2 = cos(time * 0.3) * 0.1 + 0.9; // Medium speed variation

    // Calculate displacement for each axis
    float x = sin(pos.x * baseFrequency + time) * baseAmplitude * variation1
        + cos(pos.z * baseFrequency * 2.0 + time * 1.2) * baseAmplitude * 0.5 * variation2;
    float y = cos(pos.y * baseFrequency * 0.5 + time * 0.9) * baseAmplitude * 0.3 * variation1
        + sin(pos.x * baseFrequency + time * 1.1) * baseAmplitude * 0.2 * variation2;
    float z = sin(pos.z * baseFrequency * 1.5 + time * 0.7) * baseAmplitude * 0.4 * variation1
        + cos(pos.y * baseFrequency * 2.5 + time * 1.3) * baseAmplitude * 0.3 * variation2;

    // Combine displacements into a 3D vector
    return float3(x, y, z);
}

float3 WindForce(float3 groundPos, float3 v0, float3 v2, float3 up, float h)
{
    float directAlignment = 1.0f - abs(dot(normalize(WindFunction(groundPos)), normalize(v2 - v0)));
    float heightRatio = dot((v2 - v0), up) / h;
    float alignmentValue = directAlignment * heightRatio;
    return WindFunction(groundPos) * alignmentValue;
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 vertex0 = float3(0, 0, 0);
    float3 vertex1 = v1Positions[id.x].xyz;
    float3 vertex2 = v2Positions[id.x].xyz;

    float originalLength = v1Positions[id.x].w;
    float originalWidth = v2Positions[id.x].w;

    //TODO: direction of the blade of grass
    float3 up = float3(0, 1, 0);
    float3 front = float3(0, 0, 1);

    
    // wind force: computed by using analytic functions
    float3 w = WindForce(groundPositions[id.x], vertex0, vertex2, up, originalLength) * deltaTime;
    // vertex2.x += sin(vertex2.y * 0.001 + time) * 0.0025;
    
    // stiffness force: the counterforce to previously applied forces
    float3 idleV2 = float3(0, originalLength, 0);
    float3 s = (idleV2 - vertex2) * stiffnessCoefficient * max(1 - collisionStrength, 0.1f);
    
    // gravity force
    float m = 0.5f;
    float3 g_e = m * (gravityDirection.xyz * gravityDirection.w * (1.0f - gravityParam) 
                    + normalize(gravityPoint.xyz - vertex2) * gravityPoint.w * gravityParam); // environmental gravity
    float3 g_f = 0.25f * length(g_e) * front; // front gravity
    float3 g = (g_f + g_e) * stiffnessCoefficient * deltaTime;
    
    // v2 translation
    vertex2 += s + g + w;
    
    // calculate length
    grassLength[id.x] = BezierCurveArcLength(vertex0.xy, v1Positions[id.x].xy, v2Positions[id.x].xy);
    float lengthDiff = originalLength / grassLength[id.x];

    // calculate v1 based on v2
    float lengthV0V2 = length(vertex2 - vertex0 - up * dot(vertex2 - vertex0, up)); // projected length
    vertex1.xyz  = vertex0 + grassLength[id.x] * up * max(1 - lengthV0V2/grassLength[id.x], 0.05f * max(1, lengthV0V2/grassLength[id.x]));

    // correct new length
    float3 v01 = lengthDiff * (vertex1 - vertex0);
    float3 v12 = lengthDiff * (vertex2 - vertex1);
    vertex1 = v01;
    vertex2 = vertex1.xyz + v12;

    // output
    v1Positions[id.x] = float4(vertex1, originalLength);
    v2Positions[id.x] = float4(vertex2, originalWidth);
}
