// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform float3 cameraPos;
uniform float3 cameraForward;

StructuredBuffer<int> indexGrass;
RWStructuredBuffer<int> visibleIndexGrass;
RWStructuredBuffer<uint> visibleGrassCounterBuffer;
RWStructuredBuffer<float4> v1Positions; // v1 buffer + original width
RWStructuredBuffer<float4> v2Positions; // v2 buffer + original length
StructuredBuffer<float4x4> grassWorldMatrix;

// https://docs.unity3d.com/ScriptReference/Graphics.RenderMeshIndirect.html
[numthreads(64, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// Ensure we only process valid points (TODO: no magic number)
	if (id.x < 121)
	{
		// dummy cull
		float3 groundPos = mul(grassWorldMatrix[id.x], float4(0, 0, 0, 1.0f)).xyz;
		float3 viewDir = (groundPos - cameraPos);
		float viewDist = length(viewDir);
		float3 normViewDir = viewDir / viewDist;
		float3 bladeDir = mul(grassWorldMatrix[id.x], float4(1.0f, 0, 0, 0)).xyz;
		float3 bladeUp = mul(grassWorldMatrix[id.x], float4(0, 1.0f, 0, 0)).xyz;

		// Orientation
		{
			if (abs(dot(normViewDir, bladeDir)) > 0.98f)
				return; // discard
		}

		// View Frustum Culling
		{
			// projected distance
			float3 dProj = abs(viewDir - bladeUp * dot(viewDir, bladeUp));
			float maxDist = 1000.0f;

		}

		// Distance test
		{
		}

		// Occlusion test
		{

		}
		uint val;
		InterlockedAdd(visibleGrassCounterBuffer[0], 1, val);
		visibleIndexGrass[val] = id.x; // keep track that this is a visible blade
	}
	
}
