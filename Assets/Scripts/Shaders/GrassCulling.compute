// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform float3 cameraPos;
uniform float3 cameraForward;
uniform float4x4 viewProjectionMatrix;
uniform float tolerance = 1.0f;

StructuredBuffer<int> indexGrass;
RWStructuredBuffer<int> visibleIndexGrass;
RWStructuredBuffer<uint> visibleGrassCounterBuffer;
RWStructuredBuffer<float4> v1Positions; // v1 buffer + original width
RWStructuredBuffer<float4> v2Positions; // v2 buffer + original length
StructuredBuffer<float4x4> grassWorldMatrix;

// https://docs.unity3d.com/ScriptReference/Graphics.RenderMeshIndirect.html
[numthreads(64, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// Ensure we only process valid points (TODO: no magic number)
	if (id.x < 121)
	{
		float3 bladeDir = mul(grassWorldMatrix[id.x], float4(1.0f, 0, 0, 0)).xyz;
		float3 bladeUp = mul(grassWorldMatrix[id.x], float4(0, 1.0f, 0, 0)).xyz;

		float3 groundPos = mul(grassWorldMatrix[id.x], float4(0, 0, 0, 1.0f)).xyz;
		float3 v1PositionsWorld = mul(grassWorldMatrix[id.x], float4(v1Positions[id.x].xyz, 1.0f)).xyz;
		float3 v2PositionsWorld = mul(grassWorldMatrix[id.x], float4(v2Positions[id.x].xyz, 1.0f)).xyz;
		float3 midCurvePoint = 0.25f * groundPos + 0.5f * v1PositionsWorld + 0.25f * v2PositionsWorld; 
		
		float3 viewDir = (groundPos - cameraPos);
		float viewDist = length(viewDir);
		float3 normViewDir = viewDir / viewDist;
		// Orientation
		{
			if (abs(dot(normViewDir, bladeDir)) > 0.98f)
				return; // discard
		}

		// View Frustum Culling
		{
			float4 clipPos = mul(viewProjectionMatrix, float4(groundPos, 1.0f));
			float h = clipPos.w + tolerance;
			bool groundInView = clipPos.x >= -h && clipPos.x <= h && 
						clipPos.y >= -h && clipPos.y <= h && 
						clipPos.z >= -h && clipPos.z <= h;

			clipPos = mul(viewProjectionMatrix, float4(midCurvePoint, 1.0f));
			h = clipPos.w + tolerance;
			bool midInView = clipPos.x >= -h && clipPos.x <= h && 
						clipPos.y >= -h && clipPos.y <= h && 
						clipPos.z >= -h && clipPos.z <= h;

			clipPos = mul(viewProjectionMatrix, float4(v2PositionsWorld, 1.0f));
			h = clipPos.w + tolerance;
			bool tipInView = clipPos.x >= -h && clipPos.x <= h && 
						clipPos.y >= -h && clipPos.y <= h && 
						clipPos.z >= -h && clipPos.z <= h;
			
			if (!groundInView && !midInView && !tipInView)
				return; // discard
		}
		
		// Distance test
		{
			// projected distance
			float3 dProj = abs(viewDir - bladeUp * dot(viewDir, bladeUp));
			float maxDist = 1000.0f;
		}

		// Occlusion test
		{

		}
		uint val;
		InterlockedAdd(visibleGrassCounterBuffer[0], 1, val);
		visibleIndexGrass[val] = id.x; // keep track that this is a visible blade
	}
	
}
